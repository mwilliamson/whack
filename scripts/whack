#!/usr/bin/env python

import os
import os.path
import argparse
import subprocess
import hashlib
import shutil
import contextlib
import tempfile

from whack import downloads
from whack.filelock import FileLock

def main():
    args = parse_args()
    package = args.package
    install_dir = args.install_dir
    should_cache = args.cache
    
    package_name, package_version = package.split("=")
    scripts_dir = _fetch_scripts(package_name)
    with _cache_dir_for(package, install_dir, should_cache) as cache_dir:
        if not _already_built(cache_dir):
            _build(scripts_dir, cache_dir, install_dir)
        
        _install(scripts_dir, cache_dir, install_dir)

def _already_built(cache_dir):
    return os.path.exists(cache_dir) and os.listdir(cache_dir) != []

def _build(scripts_dir, cache_dir, install_dir):
    try:
        _fetch_downloads(scripts_dir, cache_dir)
        
        subprocess.check_call(
            [os.path.join(scripts_dir, "build"), install_dir],
            cwd=cache_dir
        )
    except:
        if os.path.exists(cache_dir):
            shutil.rmtree(cache_dir)
        raise

def _fetch_downloads(scripts_dir, cache_dir):
    downloads_file_path = os.path.join(scripts_dir, "downloads")
    download_urls = _read_downloads_file(downloads_file_path)
    for url in download_urls:
        downloads.download_to_dir(url, cache_dir)

def _fetch_scripts(package):
    builders_repo_uri = "git+https://github.com/mwilliamson/whack-builders.git"
    repo_dir = downloads.fetch_source_control_uri(builders_repo_uri)
    # FIXME: race condition between this and when we acquire the lock
    package_dir = os.path.join(repo_dir, package)
    if os.path.exists(package_dir):
        return package_dir
    else:
        raise RuntimeError("No builders found for package: {0}".format(package))

def _install(scripts_dir, cache_dir, install_dir):
    subprocess.check_call(
        [os.path.join(scripts_dir, "install"), install_dir],
        cwd=cache_dir
    )

@contextlib.contextmanager
def _cache_dir_for(package, install_dir, should_cache):
    # TODO: Should also hash scripts content so that we re-build if the build scripts change
    if should_cache:
        dir_name = hashlib.sha1("{0}\n{1}".format(package, install_dir)).hexdigest()
        yield os.path.join(os.path.expanduser("~/.cache/whack/builds"), dir_name)
    else:
        cache_dir = tempfile.mkdtemp()
        yield cache_dir
        shutil.rmtree(cache_dir)

def _read_downloads_file(path):
    if os.path.exists(path):
        return [line.strip() for line in open(path) if line]
    else:
        return []
    
def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('package')
    parser.add_argument('install_dir', metavar="install-dir")
    parser.add_argument("--cache", default=False, action="store_true")
    return parser.parse_args()


if __name__ == "__main__":
    main()
